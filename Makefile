# if you ever see a segfault or other unexpected nondeterminism in this (or any other) code,
# the immediate muscle memory response should be to recompile with the following, and then
# rerun the failing use case:
# make clean && make CFLAGS="-Og -g -fno-inline -fsanitize=address,undefined"

# overrideable vars used in implicit make rules
# only default to -march=native if not on an arm mac
ifeq (,$(findstring arm64,$(shell uname -m)))
TARGET_ARCH ?= -march=native
endif

CFLAGS ?= -Os
# older versions of gcc need -fcx-limited-range, in others its effect is implied by -ffinite-math-only
ifeq (0,$(shell ${CC} -fcx-limited-range -x c -o /dev/null -c - < /dev/null 2>/dev/null; echo $$?))
	CFLAGS += -fcx-limited-range
endif

CPPFLAGS += -Wall -Wextra -Wshadow -Wmissing-prototypes
LDFLAGS += ${CFLAGS}

GIT_HASH := $(shell ((git diff --exit-code HEAD 1>/dev/null 2>/dev/null && git describe --always --tags --exact 2>/dev/null) || git describe --dirty --always 2>/dev/null) || printf 'n/a')
GIT_STAMP := $(shell TZ=UTC git log -1 --format=%cd --date=format-local:'%Y%m%dT%H%MZ' || printf 'n/a')
GIT_TIME := $(shell TZ=UTC git log -1 --format=%cd --date=format-local:'%sULL' || printf '0ULL')
CPPFLAGS += -DGIT_VERSION="\"$(GIT_HASH) ($(GIT_STAMP))\"" -DGIT_TIME=$(GIT_TIME)

# list of targets to build, generated from .c files containing a main() function:

TARGETS=bin_to_shm cobs_to_shm

all : ${TARGETS}

# for each target, the list of objects to link, generated by recursively crawling include statements with a corresponding .c file:

bin_to_shm : bin_to_shm.o shared_memory_ringbuffer.o
cobs_to_shm : cobs_to_shm.o shared_memory_ringbuffer.o

# for each object, the list of headers it depends on, generated by recursively crawling include statements:

bin_to_shm.o : shared_memory_ringbuffer.h
cobs_to_shm.o : shared_memory_ringbuffer.h
shared_memory_ringbuffer.o : shared_memory_ringbuffer.h

*.o : Makefile

clean :
	$(RM) -rf *.o *.dSYM ${TARGETS}
.PHONY: clean all
