# if you ever see a segfault or other unexpected nondeterminism in this (or any other) code,
# the immediate muscle memory response should be to recompile with the following, and then
# rerun the failing use case:
# make clean && make CFLAGS="-Og -g -fno-inline -fsanitize=address,undefined"

# overrideable vars used in implicit make rules
CFLAGS ?= -Os
CPPFLAGS += -Wall -Wextra -Wshadow -Wmissing-prototypes
LDFLAGS += ${CFLAGS}

GIT_HASH := $(shell ((git diff --exit-code HEAD 1>/dev/null 2>/dev/null && git describe --always --tags --exact 2>/dev/null) || git describe --dirty --always 2>/dev/null) || printf 'n/a')
GIT_STAMP := $(shell TZ=UTC git log -1 --format=%cd --date=format-local:'%Y%m%dT%H%MZ' || printf 'n/a')
GIT_TIME := $(shell TZ=UTC git log -1 --format=%cd --date=format-local:'%sULL' || printf '0ULL')
CPPFLAGS += -DGIT_VERSION="\"$(GIT_HASH) ($(GIT_STAMP))\"" -DGIT_TIME=$(GIT_TIME)

# list of targets to build, generated from .c files containing a main() function:

TARGETS=bin_to_shm cobs_to_shm

all : ${TARGETS}

# for each target, the list of objects to link, generated by recursively crawling include statements with a corresponding .c file:

bin_to_shm : bin_to_shm.o shared_memory_ringbuffer.o
cobs_to_shm : cobs_to_shm.o shared_memory_ringbuffer.o

# for each object, the list of headers it depends on, generated by recursively crawling include statements:

bin_to_shm.o : shared_memory_ringbuffer.h
cobs_to_shm.o : shared_memory_ringbuffer.h
shared_memory_ringbuffer.o : shared_memory_ringbuffer.h

*.o : Makefile

install : cobs_to_shm
	install -C cobs_to_shm /usr/local/bin/

uninstall :
	$(RM) /usr/local/bin/cobs_to_shm

clean :
	$(RM) -rf *.o *.dSYM ${TARGETS}
.PHONY: clean install uninstall all
